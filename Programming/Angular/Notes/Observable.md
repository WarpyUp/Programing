
**Observable** - це концепція в реактивному програмуванні, яка представляє потік даних або подій, що надходять у часі.

Думайте про це як про стрім, який може викидати (емітувати) нуль, один або багато значень протягом свого життєвого циклу.

---
### Яка різниця між Observable і Promise?

Отже:
1. **[[Promise]]** обробляє одне майбутнє значення або помилку (успіх або невдача).
2. **Observable** може обробляти кілька значень, що надходять _послідовно_ з часом, а також помилки та сигнал про завершення потоку.

**Як це працює?**
Observable — це "лінивий" (lazy) об'єкт. Він не починає працювати і випромінювати значення, доки на нього хтось не підпишеться (subscribe).

Коли ви підписуєтесь на Observable, ви стаєте його **спостерігачем (Observer)**. Спостерігач має три методи:
- `next(value):` Викликається щоразу, коли Observable випромінює нове значення. Приймає тільки один параметр.
- `error(err):` Викликається, якщо в потоці виникла помилка. Потік після цього завершується.
- `complete():` Викликається, коли потік завершився і більше не випромінюватиме значень (без помилки).

**Для чого використовується?**
- Обробка подій користувача (натискання кнопок, введення тексту), які відбуваються багато разів.
- Робота з асинхронними потоками даних (наприклад, WebSockets).
- Керування складними послідовностями асинхронних операцій.
- Observable надає потужні **оператори** (`map`, `filter`, `debounceTime`, `switchMap` тощо), які дозволяють легко перетворювати, фільтрувати та комбінувати потоки даних у декларативному стилі.

Підсумовуючи: Promise - це про _одне_ майбутнє, Observable - про _потік_ даних у часі.

---
### Code

```ts
import { Observable } from 'rxjs';

const observable = new Observable<number>((subscriber) => {
  subscriber.next(1);
  subscriber.next(2);
  setTimeout(() => {
    subscriber.next(4);
    subscriber.complete();
  }, 1000);
});

observable.subscribe({
  next(x) {
    console.log('got value ' + x);
  },
  error(err) {
    console.error('something wrong occurred: ' + err);
  },
  complete() {
    console.log('done');
  },
});
```

Коли ви створюєте `Observable` за допомогою `new Observable(...)`, ви передаєте в конструктор функцію. Ця функція називається "subscriber function" (функція підписника).

Аргументом цієї функції є об'єкт `Subscriber` (який успадковує від `Observer`), який RxJS створює для кожного окремого підписника.

**Чому не можна викликати `myObservable.next()`?** 

Тому що `myObservable` (як екземпляр класу `Observable`) сам по собі не має публічного методу `next()`. Він є джерелом, а не приймачем значень. Він лише визначає, як значення будуть випускатися, коли на нього хтось підпишеться. Ви не "вливаєте" дані в сам `Observable`, ви "запускаєте" його логіку (ту, що в `subscriber function`) під час підписки.

**Що повертає `.subscribe()`? Чому ми це не записуємо ніде?**

Якщо `Observable` сам по собі завершується (викликається `complete()`) або видає помилку (`error()`), то підписка автоматично відписується і очищається.

Якщо ваш `Observable` продовжує випускати значення протягом невизначеного часу (наприклад, події DOM, інтервали, веб-сокети, Subject), і ви не відпишетесь від нього, це може призвести до витоку памяті.
Саме в таких випадках **життєво важливо зберігати об'єкт `Subscription` і викликати `unsubscribe()`**, коли підписка більше не потрібна.



