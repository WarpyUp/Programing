
Це чисті **функції**, які дозволяють трансформувати, фільтрувати, комбінувати або маніпулювати [[Observable]]. 

Вони не змінюють оригінальний Observable, а повертають **новий** Observable.

Є два види операторів:
- Pipeable Operators
- Creation Operators

---
---
## **Pipeable Operators**

>*Pipeable Operator* — це функція, яка приймає Observable як вхідні дані і повертає інший Observable. Це чиста операція: попередній Observable залишається незмінним. 
>`{ts}observableInstance.pipe(operator)`

>*Pipeable Operator Factory* — це функція, яка може приймати параметри для встановлення контексту та повертати Pipeable Operator. Аргументи фабрики належать до лексичної області видимості оператора.
>`{ts}observableInstance.pipe(operatorFactory())`


Їх завжди використовують всередині методу `.pipe()`, створюючи ланцюжок операцій.

### Основні Pipeable Operators
#### map(project):

Перетворює кожне значення, що випромінюється вхідним Observable, застосовуючи функцію `project` до кожного значення.
```ts
of(1, 2, 3).pipe(
  map(x => x * 10)
).subscribe(data => console.log(data));
//Вивід: 10
//20
//30
```

---
#### filter(predicate):

Випромінює тільки ті значення з вхідного Observable, для яких функція `predicate` повертає *true*.

Відфільтровує значення з потоку.
```ts
of(1, 2, 3, 4, 5).pipe(
  filter(x => x % 2 === 0) // Фільтруємо лише парні числа
).subscribe(data => console.log(data));
//Вивід: 2
//4
```

---
#### tap(observerOrNext):

Виконує "побічні ефекти" для кожного значення, що випромінюється, не змінюючи сам потік.

Корисно для налагодження (логіювання) значень або виконання дій, які не впливають на дані в потоці.
```ts
of('apple', 'banana').pipe(
  tap(fruit => console.log('Обробляю фрукт: ' + fruit))
).subscribe(data => console.log('Отримано: ' + data));
//Вивід: Обробляю фрукт: apple
//Отримано: apple
//Обробляю фрукт: banana
//Отримано: banana
```

---
#### debounceTime(dueTime):

Затримує випромінювання значень з вхідного Observable на певний час `dueTime`.

Якщо протягом цього часу з'являється нове значення, попереднє відкидається, а відлік часу починається заново. Корисно для пошукових полів, щоб не робити запит після кожного натискання клавіші.
```ts
// Припустимо, у вас є поле вводу з ID "myInput"
const inputElement = document.getElementById('myInput');

fromEvent(inputElement, 'keyup').pipe(
	map((e: any) => e.target.value),
	debounceTime(500) // Чекати 500мс після останнього введення
).subscribe(value => console.log('Остаточний пошуковий запит для: ' + value));
//Вивід: (При швидкому наборі 'hello world' в полі вводу)
//Остаточний пошуковий запит для: hello world (виведеться лише після зупинки на 500мс)
```

---
#### distinctUntilChanged():

Випромінює значення лише тоді, коли воно відрізняється від попереднього випромінюваного значення.

Корисно для фільтрації повторюваних значень.
```ts
of(1, 1, 2, 2, 1, 3).pipe(
  distinctUntilChanged()
).subscribe(data => console.log(data));
//Вивід: 1
//2
//1
//3
```

---
#### switchMap(project):

Проектує кожне вихідне значення в Observable, а потім об'єднує ці внутрішні Observables в один потік, скасовуючи попередні внутрішні Observables, коли з'являється новий.

Дуже потужний для сценаріїв, де вам потрібно зробити новий асинхронний запит на основі результату попереднього, але ви хочете скасувати старий запит, якщо з'явився новий. Наприклад, автозавершення пошуку.
```ts
// Приклад імітації HTTP-запиту
const fetchUser = (id: number) => of(`User ${id} data`).pipe(delay(200));

of(1, 2, 3).pipe(
  switchMap(id => fetchUser(id)) // Для кожного ID робимо "запит"
).subscribe(data => console.log(data));
//Вивід: User 3 data (якщо 1, 2, 3 випромінюються дуже швидко, попередні "запити" можуть бути скасовані)
//Приклад з затримкою між of(1,2,3) для повної ілюстрації:
// User 1 data
// User 2 data
// User 3 data
```

У випадку `switchMap` важливо розуміти, що якщо `of(1,2,3)` випромінює значення дуже швидко, `fetchUser(1)` може бути скасований, коли почнеться `fetchUser(2)`, а `fetchUser(2)` може бути скасований, коли почнеться `fetchUser(3)`. Тому в цьому конкретному прикладі швидше за все виведеться лише `User 3 data`.

---
#### take(count):

Випромінює лише перші `count` значень з вхідного Observable, а потім завершується.

Корисно, коли вам потрібна лише обмежена кількість елементів з потоку.
```ts
interval(500).pipe(
  take(3) // Взяти лише перші 3 значення
).subscribe(
  data => console.log(data),
  null,
  () => console.log('Завершено після take(3)')
);
//Вивід: 0 (через 0.5с)
//1 (через 1с)
//2 (через 1.5с)
//Завершено після take(3)
```

---
#### takeUntil(notifier):

Випромінює значення з вхідного Observable до тих пір, поки `notifier` Observable не випромінює будь-яке значення (або не завершиться).

Надзвичайно корисний для автоматичної відписки від Observable, коли компонент знищується, запобігаючи витокам пам'яті.
```ts
const destroy$ = new Subject<void>(); // Створюємо "нотифікатор"

interval(500).pipe(
  takeUntil(destroy$) // Відписуємося, коли destroy$ випромінить
).subscribe(data => console.log(data));

// Через 2 секунди "знищуємо" (викликаємо next на Subject)
setTimeout(() => {
  destroy$.next();
}, 2000);
//Вивід: 0 (через 0.5с)
//1 (через 1с)
//2 (через 1.5с)
//(Далі нічого не виведеться, бо підписка була скасована)
```

Детальніше описано тут: [[Destroy Pattern]]

---
#### catchError(selector):

Перехоплює помилки, що випромінюються вхідним Observable, і дозволяє повернути новий Observable або викинути нову помилку.

Важливо для обробки помилок в потоках даних.
```ts
import { throwError, of } from 'rxjs';
import { catchError } from 'rxjs/operators';

throwError(() => new Error('Помилка даних')).pipe(
  catchError(error => {
    console.error('Перехоплено:', error.message);
    return of('Резервні дані'); // Повертаємо резервний Observable
  })
).subscribe(
  data => console.log(data),
  err => console.error('Кінцева помилка:', err) // Цей err не спрацює, бо помилку перехоплено
);
//Вивід: Перехоплено: Помилка даних
//Резервні дані
```

---
#### startWith(...values):

Випромінює вказані значення на самому початку потоку, ще до того, як почнуть надходити значення з вхідного Observable.

Корисно, коли вам потрібно встановити початковий стан, негайно запустити ланцюжок подій або надати значення за замовчуванням, не чекаючи на перше значення від джерела.

```ts
interval(1000).pipe(
  startWith('ПОЧАТОК!'), // Негайно випромінити це значення при підписці
  take(4) // Взяти 'ПОЧАТОК!' і перші 3 значення з interval
).subscribe(
  data => console.log(data),
  null,
  () => console.log('Завершено')
);

// Вивід:
// ПОЧАТОК!          (негайно)
// 0                 (через 1с)
// 1                 (через 2с)
// 2                 (через 3с)
// Завершено
```

---
---
## **Creation Operators**

Оператори створення – це спеціальні функції RxJS, які створюють новий Observable. Вони є початковою точкою для ваших потоків даних.

Вони дозволяють перетворити практично будь-яке джерело даних (одиничні значення, масиви, події, проміси, таймери тощо) на Observable, з яким ви потім можете працювати, використовуючи інші оператори.

### Найпоширеніші Оператори Створення:
#### of(...values):

Створює Observable, який випромінює послідовність значень, наданих як аргументи, а потім завершується.

Ідеально, коли у вас є кілька фіксованих значень, які ви хочете перетворити на потік.
```ts
of(10, 20, 'hello').subscribe(data => console.log(data));
//Вивід: `10`, `20`, `hello`, `Complete!
```

---
#### from(iterable):

Створює Observable з масиву, Promise або будь-якого іншого ітерованого об'єкта.

Випромінює кожне значення ітерації послідовно, а потім завершується.
```ts
from([1, 2, 3]).subscribe(num => console.log(num));
//Вивід: 1
//2
//3
//Complete!
```

---
#### interval(period):

Створює Observable, який випромінює послідовні числа (0, 1, 2...) кожні `period` мілісекунд.

Ніколи не завершується, якщо ви не відпишетесь.
```ts
interval(1000).subscribe(num => console.log(num));
//Вивід: 0 (через 1с)
//1 (через 2с)
//2 (через 3с)
//і так далі...
```

---
#### timer(initialDelay, period?):

Створює Observable, який випромінює 0 після `initialDelay` мілісекунд, а потім продовжує випромінювати послідовні числа кожні `period` мілісекунд (якщо `period` вказано).

Якщо `period` не вказано, він випромінює 0 після `initialDelay` і одразу завершується.

```ts
timer(2000).subscribe(() => console.log('2 секунди минуло!'));
//Вивід: '2 секунди минуло!' (через 2с)
```

```ts
timer(1000, 500).subscribe(num => console.log(num));
//Вивід: 0 (через 1с)
//1 (через 1.5с)
//2 (через 2с)
//і так далі...
```

---
#### fromEvent(target, eventName):

Створює Observable, який випромінює події DOM (або Node.js EventEmitter), що відбуваються на певному елементі.

Ідеально для обробки кліків, введення тексту, подій клавіатури тощо.
```ts
fromEvent(document, 'click').subscribe(event => console.log('Клік!', event));
//Вивід: 'Клік!', [MouseEvent об'єкт] (при кожному кліку на документ)
```

---
#### ajax(urlOrRequest):

Створює Observable для виконання HTTP-запитів.

Випромінює відповідь від сервера.
```ts
import { ajax } from 'rxjs/ajax'; 

ajax('https://jsonplaceholder.typicode.com/todos/1').subscribe(response => console.log(response.response));
//Вивід: { userId: 1, id: 1, title: 'delectus aut autem', completed: false }
```

---
#### empty():

Створює Observable, який одразу завершується без випромінювання жодних значень.

Корисно для повернення "порожнього" потоку.
```ts
empty().subscribe({
  next: () => console.log('Не має бути виведено'),
  complete: () => console.log('Observable завершено')
});
//Вивід: Observable завершено
```

---

#### never():

Створює Observable, який ніколи не випромінює жодних значень і ніколи не завершується.

Корисно для тестування або для умов, які ніколи не повинні спрацьовувати.
```ts
never().subscribe({
  next: () => console.log('Ніколи не буде виведено'),
  complete: () => console.log('Ніколи не буде виведено')
});
//Вивід: Нічого не виведе, оскільки Observable ніколи не випромінює і не завершується
```

---
#### throwError(errorFactory):

Створює Observable, який одразу ж випромінює помилку.

Корисно для обробки помилок.
```ts
import { throwError } from 'rxjs'; 

throwError(() => new Error('Щось пішло не так')).subscribe({
  next: () => console.log('Не буде виведено'),
  error: err => console.error('Перехоплена помилка:', err)
});
//Вивід: Перехоплена помилка: Error: Щось пішло не так
```

