
Signals – це реактивні примітиви, які надають спосіб гранулярного управління станом. 
Вони дозволяють Angular точно знати, які конкретні частини UI залежать від певних даних, і оновлювати лише їх, коли ці дані змінюються.

#### Як працюють?

**signal(initialValue):** Створює реактивне значення, яке можна читати і записувати. Коли його значення змінюється за допомогою `.set()` або `.update()`, всі місця, де це значення читається, автоматично оновлюються.
```ts
import { Component, signal } from '@angular/core';
@Component({
	・・・,
	template:`
		‹p> Var's value: {{ myVar() }}</p>
	`
})
class MyComponent {
	myVar = signal('some value');
	//або вказати явно за допомогою [[Generic Classes|generic]]
	myVar = signal<string>('some value');
	//set value
	myVar.set("new value");
}
```

**computed():** Створює похідне (обчислюване) значення на основі одного або кількох інших сигналів. Воно оновлюється лише тоді, коли змінюються його вхідні сигнали, і кешується для продуктивності.
```ts
doubleCount = computed(() => this.count() * 2);
```

**effect():** Дозволяє запускати побічні ефекти (наприклад, оновлення DOM, виклики API) у відповідь на зміни сигналів.


### Передавання інформації з одного компоненту в інший - Функції: input(), output()

---

**input()** - це функція, яка повертає Signal. Вхідні дані автоматично стають реактивним сигналом. Коли батьківська властивість змінюється, сигнал `input()` оновлюється, і Angular знає, які саме частини шаблону залежать від цього сигналу, оновлюючи їх.

Greeting очікує інпут
```ts title:greetings.ts
export class Greeting {  
  message = input('Default Input');  
  // or can be
  message = input.required();
}
```
і виводить його
```html title:greeting.html 
<p>{{message()}}</p>
```

Home створює сигнал на передачу
```ts title:home.ts
export class Home {  
  messageHome = signal("Message from Home to Greetings");  
}
```
і передає його 
```html title:home.html 
<app-greeting [message] = "messageHome()" />
```

---

**output()** - це функція, яка повертає об'єкт для випромінювання подій. Вона надає більш декларативний спосіб визначення подій.

```ts title:child.ts
import { Component, output } from '@angular/core'; // Імпорт "output" як функції

@Component({
  selector: 'app-child-new',
  template: `<button (click)="buttonClick.emit()">Клікни (Новий)</button>`
})
export class ChildNewComponent {
  buttonClick = output<void>(); // Визначаємо output як функцію
}
```

Parent HTML
```html
<app-child-new (buttonClick)="handleChildClickNew()"></app-child-new>
```

#### Передача змінної в input()

Якщо значення є статичним, або звичайною властивістю, яка оновлюється звичайною зміною детектору.

- Дочірній `input()` все одно перетворює її на сигнал.
- Але якщо `myVariable` змінюється в батьківському компоненті, Angular дізнається про це завдяки загальному циклу виявлення змін (через Zone.js).
- Цей загальний цикл може бути менш ефективним у дуже великих додатках, оскільки він перевіряє багато речей, навіть якщо змінилася лише одна змінна.

#### Передача змінної сигналом

Якщо значення є сигналом, яким батьківський компонент активно керує як частиною своєї власної реактивної системи (наприклад, воно оновлюється через `.set()`/`.update()`, або це `computed()` Signal).

Значення часто змінюється (або може часто змінюватися) в самому батьківському компоненті.

Ця змінна є частиною реактивного стану батьківського компонента, який ви вже керуєте за допомогою Signals (наприклад, це лічильник, який оновлюється при кліках, або дані з форми, які змінюються під час введення).

Ви хочете скористатися гранулярною реактивністю Signals для оптимізації продуктивності батьківського компонента та його взаємодії з дочірніми.

**Приклад:** Якщо в батьківському компоненті є кнопка "Збільшити", яка змінює `count` `signal()`, тоді передавати `[count]="currentCount()"` в `input()` дочірнього - це логічно.