
**Асинхронне програмування** — це парадигма програмування, яка дозволяє виконувати кілька завдань "одночасно" без блокування основного потоку виконання програми.

Давайте порівняємо з **синхронним** програмуванням.
### Відмінність синхронного і асинхронного

**Синхронне програмування:**
- Завдання виконуються послідовно, одне за одним.
- Кожна операція повинна завершитися, перш ніж почнеться наступна.
- Якщо одна операція займає багато часу (наприклад, завантаження даних з інтернету), вся програма "завмирає" і не відповідає, доки ця операція не завершиться.

**Асинхронне програмування:**
- Завдання ініціюються, але програма не чекає їхнього негайного завершення.
- Програма продовжує виконувати інші завдання, поки фонові асинхронні операції працюють.
- Коли асинхронна операція завершується, вона повідомляє програму про свій результат (наприклад, викликаючи функцію зворотного виклику, використовуючи [[Promise]] або [[Observable]], як в [[RxJS]]).

### Чому це важливо в Angular?

Angular-додатки мають інтерактивний користувацький інтерфейс (UI). 
Більшість дій в сучасних веб-додатках є асинхронними:
- **HTTP-запити:** Отримання даних з сервера (API). Це може зайняти час через мережеві затримки. Якщо б це було синхронно, UI зависав би щоразу, коли ви завантажуєте дані.
- **Події користувача:** Кліки миші, введення тексту, натискання клавіш. Ви не знаєте, коли користувач виконає ці дії, тому програма має бути готовою реагувати на них у будь-який момент.
- **Таймери та інтервали:** Затримки, анімації, періодичне оновлення даних.
- **Робота з локальним сховищем, файлами тощо.**

Асинхронне програмування дозволяє вашому Angular-додатку залишатися чуйним:
- UI не "зависає", поки дані завантажуються. Користувач може взаємодіяти з іншими елементами сторінки.
- Ви можете легко реагувати на події користувача, коли вони відбуваються.

### Як це реалізується?

В JavaScript асинхронність реалізується за допомогою:
- Callback
- [[Promise]]
- async/await
- [[Observable]]

#### Callbacks (функції зворотного виклику):

Функція, яка передається в іншу функцію і викликається після завершення асинхронної операції. Історично це був перший спосіб, але може призвести до "callback hell" через надмірну вкладеність послідовних дій.
```js
async function pageLoader(callback) {  
	const data = await fetch('http://example.com/movies.json')  
	callback(data)  
}
```
```js
function onPageLoadingFinished(pageData) {  
  console.log('Page was sucessfully loaded!')  
}
pageLoader(onPageLoadingFinished)
```

Щоб вирішити якось проблему пекельного кола колбеків було створено проміси (promise).

#### Promise

![[Promise]]

#### async/await

Для отримання асинхронності не обов’язково використовувати проміси. Є крок значно простіший — використати [[async, await]].  
 
Слово *async* додане до функції (function declaration чи function expression) робить її асинхронною повертаючи результат у вигляді об’єкту промісу, лишається зазначити через _await_ на завершення якої частини коду ми хочемо почекати. 

По суті це синтаксичний цукор над промісами.

```js
async function logFetch(url) {  
	const response = await fetch(url);  
	console.log(await response.text());  
}
```

