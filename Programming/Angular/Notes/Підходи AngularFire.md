
Існує два підходи або способи використання AngularFire для використання даних [[Firestore]].

---
## Новий підхід(Функціональний)

[[Функціональний API|Посилання]]

Це сучасний, рекомендований спосіб. Ви імпортуєте окремі функції.

Це стиль, який використовується в **AngularFire версії 7 і новіших**. Його ще називають "tree-shakable" API.

Ви імпортуєте основний сервіс `Firestore`, а потім окремо імпортуєте **тільки ті функції**, які вам потрібні для роботи з базою (`collection`, `doc`, `addDoc` тощо).

**Аналогія:** Уявіть, що у вас є ящик з інструментами. Замість того, щоб брати весь ящик, ви берете з нього тільки молоток і викрутку, бо вам потрібні лише вони.
### Код
Впроваджуємо Firestore в конструкторі
```ts
constructor(private firestore: Firestore) { }
```

Використовуємо метод collection, щоб отримати посилання на колекцію
```ts
const notesCollection = collection(this.firestore, 'notes');
```

І отримуємо [[Observable]]:
```ts
notes$: Observable<any[]>;
this.notes$ = collectionData(notesCollection);
```

Детальніше описано в [[Считування з Firebase]]

---
## Старий підхід(Обєкто орієнтований)

[[Обєктно Орієнтований API|Посилання]]

Це застарілий спосіб, який використовувався у старих версіях AngularFire. Використовувався в **AngularFire версії 6 і раніше**.

Ви імпортуєте один великий сервіс `AngularFirestore` (який часто називають `afs`), і цей об'єкт вже має в собі всі можливі методи (`.collection()`, `.doc()`, `.createId()` тощо).

### Код
Впроваджуємо великий серівс
```ts
constructor(private afs: AngularFirestore) {}
```

Викликаємо метод collection і valueChanges() для отримання Observable
```ts
this.notes$ = this.afs.collection('notes').valueChanges();
```

