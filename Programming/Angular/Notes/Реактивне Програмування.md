
**Реактивне програмування** — це парадигма програмування, у якій основна увага приділяється потокам даних та їхній автоматичній обробці в реальному часі. Реактивне програмування передбачає швидку реакцію програми на зміни, а також використання [[Асинхронне Програмування|асинхронних]] операцій.

Слово “реактивний” у програмуванні означає підхід, коли система автоматично реагує на зміни даних, подій або стану. Це протилежність “імперативному” стилю, де ви самі явно вказуєте, коли і що оновлювати.

Можна виділити декілька особливостей реактивного програмування:
- орієнтовано на взаємодію з асинхронними потоками даних
- потоки мають можливість передавати і отримувати інші потоки даних
- дані, які передаються по потоках, слухаються підписниками
- підписники реагують на зміни даних

Для чіткого розуміння реактивного програмування в JS, для прикладу, надалі, будемо використовувати бібліотеку [[RxJS]] і відповідні реалізації бібліотеки ([[Observable]], Subject, BehaviourSubject).

---
### Яка різниця між [[Observable]] і [[Promise]]?

Promise спрацьовує одразу після його створення, і згідно умови видає очікуваний результат, або помилку, повертаючи при цьому новий обєкт Promise, скасувати його неможливо.

**Observable працює зовсім по-іншому:**

По-перше, після створення нашого стріма (через об’єкт Observable або через оператори створення of, from) потрібно обовязково підписатись subscribe. Без підписки стрім не буде працювати і ви опинитесь у вічному очікуванні, на відміну від Promise, якому підписка не потрібна.  

По-друге, stream — це довільний набір даних, який можна доповнювати, перезаписувати, трансформувати, фільтрувати, обєднювати (обєднювати з іншими стрімати), переривати, що не властиво Promise -він просто створюється і викликається.  

Ну і по-третє, стрім можна уявити як щось з нашого життя, підписка на ютуб канал, як тільки вийде відео, ви обовязково про нього дізнаєтесь.

**Якщо Promise — це константа, то Observable(stream) — це Array<змінних>.**

Уявімо собі кран з водою і трубу, яка приєднана до цього крану.  
Відкриваючи кран вода починає текти по трубі, вода в даному прикладі є **stream**(певний потік даних), тут і проявляє себе реактивне програмування в найкращому вигляді.

Справа в тому, що тепер ми можемо працювати з цією трубою **pipe** як нам заманеться, припустимо, ми хочемо щоб наша вода фільтрувалась від сторонніх домішків, ми приєднаємо фільтр для води на одному з кінців труби:

```js
const observable = new Observable((subscriber) => { 
	subscriber.next('брудна вода');  
	subscriber.next('чиста вода');  
});  

console.log('перед підпискою');  
observable  
.pipe(  
	filter((water) => water === 'чиста вода')
)
.subscribe({
	next(x) {  
		console.log('чиста вода ->', x);  
	}, 
	error(err) {  
		console.error('something wrong occurred: ' + err);  
	},  
	complete() {  
		console.log('done');  
	},  
});  
console.log('після підписки');
```

Далі ми вирішуємо підігрівати нашу воду до комфортної температури:
```js
const observable = new Observable((subscriber) => { 
	subscriber.next('брудна вода');  
	subscriber.next('чиста вода');  
});  

console.log('перед підпискою');  
observable  
.pipe(  
	filter((water) => water === 'чиста вода'),
	map((filteredWater) => 'тепер це тепла вода, ' + filteredWater)
)
.subscribe({
	next(x) {  
		console.log('чиста вода ->', x);  
	}, 
	error(err) {  
		console.error('something wrong occurred: ' + err);  
	},  
	complete() {  
		console.log('done');  
	},  
});  
console.log('після підписки');
```

А тепер уявімо, що нам потрібно провести воду до декількох точок, і як тільки кран буде відкритим, вода буде розгалужуватись на дві труби. 

З технічної сторони реактивного програмування нам потрібні новий підписник (загалом у нас буде 2 підписника на стрім, і всі підписники зможуть отримувати необхідну інформацію).

```js
const observable = new Observable((subscriber) => { 
	subscriber.next('брудна вода');  
	subscriber.next('чиста вода');  
});  

console.log('перед підпискою');  

const rootObservable = observable  
.pipe(  
	filter((water) => water === 'чиста вода'),
	map((filteredWater) => 'тепер це тепла вода, ' + filteredWater)
);

let observable_1 = rootObservable;  
let observable_2 = rootObservable;  

observable_1.subscribe({  
	next(x) {  
		console.log('чиста вода для першого підписника ->', x);  
	},  
	error(err) {  
		console.error('something wrong occurred: ' + err);  
	},  
	complete() {  
		console.log('done');  
	},  
});  
  
observable_2.subscribe({  
	next(x) {  
		console.log('чиста вода для другого підписника ->', x);  
	},  
	error(err) {  
		console.error('something wrong occurred: ' + err);  
	},  
	complete() {  
		console.log('done');  
	},  
});  
console.log('після підписки');
```

Фактично, ми втручаємось в нашу трубу pipe в якій тече наша вода stream і робимо з нею що забажаємо =)

Для цього існують методи ([[Operators|pipeble operators]]), які можна використовувати для фільтрації, трансформації і т.д. нашого стріму (в даному випадку води).

Окрім `Observable`, в бібліотеці RxJS існуються інші, схожі, обєкти: `Subject`, `BehaviourSubject`, `ReplaceSubject`, `AsyncSubject`.

---
### Observable vs Subject

[[Subject]] дуже схожий на Observable, його можна створити через оператор new, на нього можна підписатись subscribe, і його стрім можна змінювати за допомогою pipe.  
Відмінність в тому, що його підписник водночас може бути і джерелом стріма.

```js
let sub = new Subject();  
  
sub.subscribe(  
	(value) => {  
		console.log(value);  
}  
);  
  
sub.next('вода');
```

Уявіть собі ситуацію, у вас є квартира, в квартирі є всі проведені труби, і все у вас чудово, але раптово ваш місцевий “Водоканал” перекриває воду у цілому районі, і відповідно ваш багатоквартирний будинок залишається без води.  
По графіку включень, воду планують пустити через годину, що буде далі відбуватись?  

Як тільки “Водоканал” пустить воду в ваш будинок, усі квартири у яких проведені труби негайно отримають воду, це означає, що “Водоканал” є джерелом стріма, а квартири є підписниками.  
Тут важливий момент, що “Водоканал” також може бути підписником, тому що там також є крани, і місцеві працівники можуть користуватись водою, і заварювати чай.

```ts
// RxJS v6+  
import { Subject } from 'rxjs';  
  
const sub = new Subject<number>();  
  
sub.next(1);  
sub.subscribe(x => {  
	console.log('Subscriber A', x);  
});  
sub.next(2); // OUTPUT => Subscriber A 2  
sub.subscribe(x => {  
	console.log('Subscriber B', x);  
});  
sub.next(3); // OUTPUT => Subscriber A 3, Subscriber B 3 (logged from both subscribers)
```


Інше порівняння, це YouTube.  
Observable -> звичайне відео на ютубі.  
Subject -> ойлайн трансляція (ютуб стрім).

Якщо ви відкриваєте нове ютуб відео, ви починає дивитись його з самого початку, ваш друг\сусід\колега який знаходиться біля вас також може увімкнути те ж саме відео, як тільки він це зробить, він теж зможе дивитись відео з самого початку, не важливо на якій хвилині відео находитесь ви на своєму девайсі.  
Тобто, кожен новий підписник Observable буде отримувати дані з самого початку, ті які є в Observable.  
**Такий підхід називають ‘cold observable’.**

Якщо ви відкриваєте онлайн трансляцію на ютубі (ютуб стрім), ви являєтесь новим підписником, і те, що ви будете бачити, може бути початком\серединою\кінцем стріма, якщо стрім почався годину тому, гарантовано ви будете його спостерігати не з самого початку, а відповідно на годину пізніше вій його початку.  
Відповідно, якщо ваш друг\сусід\колега відкриє цей самий стрім, він буде спостерігати відео на тому ж моменті, на якому й ви, але втратить початок цього стріма, так як підписався на нього значно пізніше.  
**Такий підхід називають ‘hot observable’.**

Subject, на відміну від Observable, по замовчуванню є ‘hot observable’.

---
### BehaviourSubject і ReplaceSubject

**BehaviourSubject** — клас, який наслідує методи і властивості класу Subject, але з різницею в тому, що він може мати початкові дані\початковий стейт.

**ReplaySubject** — клас, який наслідує методи і властивості класу Subject.
Зберігає в буфер значення потоку. Розмір буферу задається в функції конструкторі. Нова підписка миттєво отримає вміст буферу.

### AsyncSubject

**_AsyncSubject_** — клас, який наслідує методи і властивості класу Subject. Передає в потік тільки останнє значення і тільки після завершения.